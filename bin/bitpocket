#!/bin/bash

#
# rsync based sync script - heavily based on bitpocket from
# https://github.com/sickill/bitpocket
# simplified by omiting the approach to preserve directory timestamps
# and fully relying on rsync - no ssh to remote systems
#
#set -x

LANG=$(locale | grep LANG= | sed 's:LANG=::')
if [[ -z "$LANG" ]]; then
    LANG="C"
fi

export LC_ALL=$LANG # for stable "sort" output

REMOTE_LOCK_NAME=remotelock
# Paths
DOT_DIR=.bitpocket
CFG_FILE="$DOT_DIR/config"
TMP_DIR="$DOT_DIR/tmp"
STATE_DIR="$DOT_DIR/state"
REMOTE_LOCK_DIR="$DOT_DIR/$REMOTE_LOCK_NAME"
LOCK_DIR="$TMP_DIR/lock"  # Use a lock directory for atomic locks. See the Bash FAQ http://mywiki.wooledge.org/BashFAQ/045


# Default settings
SLOW_SYNC_TIME=10
SLOW_SYNC_FILE="$TMP_DIR/slow"
RSYNC_RSH="ssh"
[ "$RSYNC_SSH_OPTIONS" = "" ] && RSYNC_SSH_OPTIONS="ssh"
[ "$REMOTE_LOCK_WAIT" = "" ] && REMOTE_LOCK_WAIT=1
[ "$REMOTE_LOCK_TIMEOUT" = "" ] && REMOTE_LOCK_TIMEOUT=1800
REMOTE_BACKUPS=false
BACKUPS=true
LOCAL_MOUNTPOINT=false

# Default command-line options and such
COMMANDS=()
ARGS=()
OPTIONS=()
function usage {
  cat <<EOF  
usage:  bitpocket { init [<REMOTE_HOST>] <REMOTE_PATH>
                  | sync | help | pack | log | cron | list }

Available commands:
   sync    Run the sync process. If no command is specified, sync is run by
           default.
   init    Initialize a new bitpocket folder. Requires path and optional
           remote host params. Remote path must already exist.
   pack    Pack any existing (automatic) backups into a git repository.
   cron    Run sync optimized for cron, logging output to file instead of
           stdout.
   log     Display the log generated by the cron command
   list    List all files in the sync set (honoring include/exclude/filter
           config).
   help    Show this message.

Options:
   -f, --force      Clean up stale lock files automatically
   -p, --pretend    Don't really perform the sync or update the current
                    state. Instead, show what would be synchronized.
   -b, --base       base dir

Note: All commands (apart from help), must be run in the root of a
      new or existing bitpocket directory structure.
EOF
}

function parseargs() {
    while [[ -n $1 ]]; do
        case $1 in
            # Switches and configuration
            -p|--pretend)   OPTIONS+=('pretend');;
            -f|--force)     OPTIONS+=('force');;
        -b|--basedir)   if [[ $# -lt 2 ]] ; then
                    usage
                exit 128
                fi
                    BASEDIR=$2
                    shift
                    cd $BASEDIR || exit 1
                    ;;      
            -h|--help|-*)   COMMANDS+=('help');;
            # Arguments (commands)
            init)           if [[ $# -lt 2 ]]; then
                                echo "usage: bitpocket init [<REMOTE_HOST>] <REMOTE_PATH>"
                                exit 128
                            fi
                            COMMANDS+=("$1")
                            ARGS+=("$2")
                            if [[ $# -gt 2 ]]; then
                                ARGS+=("$3")
                                shift;
                            fi
                            shift;;
            sync|pack|cron|log|list|help)
                            COMMANDS+=("$1");;
            # Anything else
            *)              echo "!!! Invalid command: $1"
                    exit 1;;
        esac
        shift
    done
}

parseargs "$@"


# Load config file
[[ -f "$CFG_FILE" ]] && . "$CFG_FILE"

if [ "$REMOVE_STALE_LOCKS" = "true" ] ; then
    OPTIONS+=("force")
fi
# Colors
GREEN=""
RED=""
CLEAR=""
YELLOW=""
if [[ -t 1 ]]; then
    GREEN="\x1b\x5b1;32m"
    RED="\x1b\x5b1;31m"
    YELLOW="\x1b\x5b1;33m"
    CLEAR="\x1b\x5b0m"
fi

# Test for GNU versions of core utils. Bail if non-GNU.
if sed --version >/dev/null 2>/dev/null; then
    alias cp="cp --parents --reflink=auto"
else
    echo "\
Warning: ---------------------------------------------------
It seems like you are running on a system without GNU coreutils.  bitpocket
may not work correctly on this platform. Please beware and report any issues
you encounter.
"
    alias sed="sed -E"
fi

# Decide on runner (ssh / bash -c)
function setup_remote() {
    if [[ -n "$REMOTE_HOST" ]]; then
      REMOTE="$REMOTE_HOST:$REMOTE_PATH"
    else
      REMOTE="$REMOTE_PATH"
    fi
}
setup_remote

REMOTE_TMP_DIR="$REMOTE_PATH/$DOT_DIR/tmp"
HOSTNAME="$(hostname)"

# Don't sync user excluded files
if [[ -f "$DOT_DIR/exclude" ]]; then
  user_exclude="--exclude-from $DOT_DIR/exclude"
fi

# Specify certain files to include
if [[ -f "$DOT_DIR/include" ]]; then
  user_include="--include-from $DOT_DIR/include"
fi

# Specify rsync filter rules
if [[ -f "$DOT_DIR/filter" ]]; then
  # The underscore (_) is required for correct operation
  user_filter="--filter merge_$DOT_DIR/filter"
fi

USER_RULES="$user_filter $user_include $user_exclude"

TIMESTAMP=$(date "+%Y-%m-%d.%H%M%S")
LOCK_TIMESTAMP=$(date "+%s")

export RSYNC_RSH

function prefix() {
    while read -r line; do
        echo "$1$line"
    done
}

function init {
  if [[ -d "$DOT_DIR" || -f "$CFG_FILE" ]]; then
    echo "fatal: Current directory already initialized for bitpocket"
    exit 128
  fi

  if [[ $# == 2 ]]; then
    REMOTE_HOST=$1
    shift
  fi

  REMOTE_PATH="$1"
  setup_remote
  rsync -e "$RSYNC_SSH_OPTIONS" $RSYNC_OPTS --list-only --include="." --exclude="**" "$REMOTE/"
  if [ $? != 0 ] ; then
      echo "fatal: $REMOTE: remote not accessible"
      exit 128
  fi
  mkdir "$DOT_DIR"

  cat <<EOF > "$CFG_FILE"
## Host and path of central storage
REMOTE_HOST=$REMOTE_HOST
REMOTE_PATH="$REMOTE_PATH"
RSYNC_SSH_OPTIONS="$RSYNC_SSH_OPTIONS"
#set a timeout after which remote locks are ignored
REMOTE_LOCK_TIMEOUT="$REMOTE_LOCK_TIMEOUT"
#set a time to wait for acquiring a remote lock 
REMOTE_LOCK_WAIT="$REMOTE_LOCK_WAIT"
#avoid any direct ssh commands, always use rsync

#always remove stale local locks (default: false)
#REMOVE_STALE_LOCKS=true

## Backups -----------------------------------
## Enable file revisioning locally in the pull phase (>false< to disable)
BACKUPS=true
## Make revisions of files on the REMOTE_HOST in the push phase.
REMOTE_BACKUPS=false

## Rsync Advanced Options --------------------
## SSH command with options for connecting to \$REMOTE
# RSYNC_RSH="ssh -p 22 -i $DOT_DIR/id_rsa"

## Uncomment following line to follow symlinks (transform it into referent file/dir)
# RSYNC_OPTS="-L"

## Use the following if a remote FAT or VFAT filesystem is being synchronized.
## This is automatically detected for local FAT filesystems.
# RSYNC_OPTS="--no-perms --no-owner --no-group --modify-window=2"

## Uncomment following lines to get sync notifications
# SLOW_SYNC_TIME=10
# SLOW_SYNC_START_CMD="notify-send 'BitPocket sync in progress...'"
# SLOW_SYNC_STOP_CMD="notify-send 'BitPocket sync finished'"

## Indicate a remote mount point. If this is set and the mountpoint is not
## mounted, then the bitpocket sync will abort. This addresses situations where
## a sync target appears empty because it is not mounted.  Such a sync might
## result in all local or remote data disappearing. Give the expected
## mountpoint of the local and/or remote target.
EOF

  echo "Initialized bitpocket directory at $(pwd)"
  echo "Please have a look at the config file ($DOT_DIR/config)"
}

function log {
  assert_dotdir
  tail -f "$DOT_DIR/log"
}

function prefix() {
    while read -r line
    do
        echo "$1$line"
    done
}

function pull() {
  # Actual fetch
  # Pulling changes from server
  # Order of includes/excludes/filters is EXTREMELY important
  echo
  echo "# Pulling changes from server"

  local BACKUP_TARGET="$DOT_DIR/backups/$TIMESTAMP"
  local DO_BACKUP=""

  if [[ $BACKUPS == true ]]
  then
      echo "# >> Saving current state and backing up files (if needed)"
      local DO_BACKUP="--backup --backup-dir=$BACKUP_TARGET"
  fi


  # Determine what will be fetched from server and make backup copies of any
  # local files to be deleted or overwritten.
  #
  # Only delete locally if deleted remotely.
  # we preserve files from local-add-change and local-del
  #
  # Order of includes/excludes/filters is EXTREMELY important
  #
  # TODO: Consider adding %U and %G to the output format to capture owner and
  # group changes
  rsync -O -e "$RSYNC_SSH_OPTIONS" -auzx --delete $RSYNC_OPTS --exclude "/$DOT_DIR" \
        --filter=". $TMP_DIR/local-del" \
        --filter=". $TMP_DIR/local-add-change" \
        $DO_BACKUP \
        --out-format=%i:%B:%n \
        $USER_RULES $REMOTE/ . \
  | detect_changes \
  | prefix "  | " || die "PULL"

  # Some versions of rsync will create the backup dir, even if it doesn't get
  # populated with any backups
  if [[ -d "$BACKUP_TARGET" ]]
  then
      if (shopt -s nullglob dotglob; f=("$BACKUP_TARGET"/*); ((${#f[@]})))
      then
          echo "  | Some files were backed up to $BACKUP_TARGET"
      else
          echo "  | No files were backed up to $BACKUP_TARGET, cleaning up"
          rmdir "$BACKUP_TARGET"
      fi
  else    
    echo "  | No files were backed up to $BACKUP_TARGET, cleaning up"
  fi
}

function detect_changes() {
    # TODO: we do not need this really....
    # Create a duplicate of STDOUT for logging of backed-up files, and use fd#4
    # for logging of deleted files, which need to be sorted
    exec 3> "$STATE_DIR/pull-current"

    while read -r line
    do
        IFS=":" read -ra info <<< "$line"
        operation=${info[0]}
        filename="${info[*]:2}"
        if [[ "$operation" =~ ^\*deleting ]]
        then
            echo "d ./${filename}" >&3
        elif [[ "$operation" =~ \+\+\+\+$ ]]
        then
            echo "w ./$filename" >&3
        fi
        echo "$operation $filename"
    done

    exec 3>&-
}

function push() {
  # Actual push

  # Send new and updated, remotely remove files deleted locally
  # Order of includes/excludes/filters is EXTREMELY important
  echo
  echo "# Pushing changes to server"

  local BACKUP_TARGET="$DOT_DIR/backups/$TIMESTAMP"
  local DO_BACKUP=""
  if [[ $REMOTE_BACKUPS == true ]]
  then
      echo "# >> Saving current state and backing up files (if needed)"
      DO_BACKUP="--backup --backup-dir=$BACKUP_TARGET"
  fi

  # Do not push back remotely deleted files
  rsync -O -e "$RSYNC_SSH_OPTIONS" -auzxi --delete $RSYNC_OPTS --exclude "/$DOT_DIR" \
        $DO_BACKUP \
        $USER_RULES . $REMOTE/ \
  | prefix "  | " || die "PUSH"

}

function scrub_rsync_list {
    # Capture the 1st and 5th columns (mode and file name), remove blank lines,
    # drop the `/.` folder/file, and escape files with `[*?` characters in
    # them. Use the ASCII "file separator" (0x1c) to separate the filename from
    # the file mode in the output.
    sed -En '/^[dl-]/ {
        s:^([^[:space:]]*)[[:space:]]*[^[:space:]]*[[:space:]]*[^[:space:]]*[[:space:]]*[^[:space:]]*[[:space:]]*(.*$):\:\1/\2:
        /\/\.$/ b
        s:([*?[]):\\\1:g
        p
    }'
}

#omit the leading . and escape wildcards in filenames
function find_to_filter {
  sed -n "s?^\.\([^ ][^ ]*\)?$1 \1?p"| sed 's:\([*?[]\):\\\1:g'
}

function create_sync_start {
  touch "$STATE_DIR/new-sync"
}

#should be run in background to be as atomic as possible...
function finish_sync {
  trap '' SIGHUP SIGABRT SIGINT SIGQUIT SIGILL SIGTRAP SIGFPE SIGPIPE SIGTERM SIGSTOP 
  #the following operations should be somehow atomic	
  mv -f "$STATE_DIR/new-sync" "$STATE_DIR/last-sync" || die "unable to create sync marker"
  mv -f "$STATE_DIR/tree-current" "$STATE_DIR/tree-last"
  mv -f "$STATE_DIR/pull-current" "$STATE_DIR/pull-last"
}

function analyse {
  # Check what has changed
  # simpliefied approach:
  # check for local changes after the last sync start (mtime against last-sync) -> local-add-change, preserve them from deletes
  # check for local deletes (compare tree-last with tree-current) -> local-del and omit them completely from the pull
  # the last deletes from remote (pull-delete) will be substracted from the list 
  # remaining issues:
  # (1) if a remote file gets changed during the sync it will be stored with a mtime > last-sync
  #     this will prevent it from being deleted on the next sync if afterwards it would be deleted remotely (and this way will be transferred back)
  #     maybe acceptable as it would only affect deletes (i.e. file would come back)
  # (2) we completely rely on rsync checking the timestamps - this could cause trouble if local and remote time stamps differ
  # (3) a file is locally changed/deleted when the sync is running - we don't know which one will finally win - but this problem is always there
  # all of the problems will finally create backups on bot sides
  echo "# Capturing current local state "
  echo "  | Root dir: $(pwd)"

  # Collect the current snapshot of the local tree
  find . | sort > "$STATE_DIR/tree-current"
  if [ -e "$STATE_DIR/last-sync" -a -s "$STATE_DIR/tree-last" ]; then
    find . -newer "$STATE_DIR/last-sync" | find_to_filter P > "$TMP_DIR/local-add-change" || die "unable to create local-add-change"
    [ ! -f "$STATE_DIR/pull-current" ] && touch "$STATE_DIR/pull-current"
    [ ! -f "$STATE_DIR/pull-last" ] && touch "$STATE_DIR/pull-last"
    cat "$STATE_DIR/pull-current" "$STATE_DIR/pull-last" | sed -n 's/^d //p'|sort|uniq > "$TMP_DIR/pull-del"
    comm -23 "$STATE_DIR/tree-last" "$STATE_DIR/tree-current" | comm -23 - "$TMP_DIR/pull-del" | find_to_filter '-' > "$TMP_DIR/local-del" || die "unable to create local-del"
  else
    echo "" > "$TMP_DIR/local-del" || die "unable to create local-del"
    cat "$STATE_DIR/tree-current" | find_to_filter P > "$TMP_DIR/local-add-change" || die "unable to create local-add-change"
  fi  
}

function strip_mode {
      cut -c12-
}

# Do the actual synchronization
function sync {
  assert_dotdir
  acquire_lock
  acquire_remote_lock_rsync
  create_sync_start
  detect_fatfs

  echo
  echo -e "${GREEN}bitpocket started${CLEAR} at $(date)."
  echo

  # Fire off slow sync start notifier in background
  on_slow_sync_start

  # Build addtion/deletion lists
  analyse

  if [[ "${OPTIONS[*]}" =~ pretend ]]; then
      RSYNC_OPTS="${RSYNC_OPTS} --dry-run"
      echo -e "${YELLOW}Pretending to sync only. No changes will be made${CLEAR}"
  fi

  pull
  push
  finish_sync &
  wait $!

  # Fire off slow sync stop notifier in background
  on_slow_sync_stop

  cleanup
  echo
  echo -e "${GREEN}bitpocket finished${CLEAR} at $(date)."
  echo

}

# Pack backups into a git repository
function pack {
    assert_dotdir

    # Git is required for backup packing
    if ! builtin type -p git > /dev/null; then
        echo "fatal: For backup packing, git must be installed"
        exit 128
    fi

    # If pack directory is missing, create it and prepare git repo
    if [ ! -d "$DOT_DIR/pack" ]
    then
        mkdir    $DOT_DIR/pack
        git init $DOT_DIR/pack
        touch    $DOT_DIR/pack/.git-init-marker
        (cd $DOT_DIR/pack && git add .)
        (cd $DOT_DIR/pack && git commit -a -q -m "INIT")
    fi

    # If any backups exist, pack them into the repo
    if [ -d "$DOT_DIR/backups" ] && [ "$(ls -A $DOT_DIR/backups)" ]
    then
        for DIR in $DOT_DIR/backups/*
        do
            TSTAMP=$(echo $DIR | sed "s|.*/||")
            if [ "$(ls -A $DIR)" ]
            then
                echo -n "Processing: $TSTAMP ... "
                echo -n "Moving ... "
                (cp -rfl $DIR/* $DOT_DIR/pack && rm -rf $DIR)        || die MV
                echo -n "Adding ... "
                (cd $DOT_DIR/pack && git add .)                      || die ADD
                echo -n "Committing ... "
                # Commit only if repository has uncommitted changes
                (cd $DOT_DIR/pack \
                    && git diff-index --quiet HEAD \
                    || git commit -a -q -m "$TSTAMP" )             || die COMMIT
                echo "Done."
            else
                echo "Removing empty dir $DIR  ..."
                rmdir $DIR
            fi
        done
        echo "Running 'git gc' on pack dir"
        du -hs $DOT_DIR/pack
        (cd $DOT_DIR/pack && git gc) || die GC
        du -hs $DOT_DIR/pack
        echo "All snapshots packed successfully."
    else
        echo "No unpacked backups found ..."
    fi

}

function on_slow_sync_start {
  if [ -n "$SLOW_SYNC_START_CMD" ]; then
    rm -rf "$SLOW_SYNC_FILE"
    (sleep $SLOW_SYNC_TIME && touch "$SLOW_SYNC_FILE" && eval "$SLOW_SYNC_START_CMD" ; wait) &
    disown
    shell_pid=$!
  fi
}

function on_slow_sync_stop {
  if [ -n "$shell_pid" ]; then
    kill $shell_pid &>/dev/null

    if [[ -n "$SLOW_SYNC_STOP_CMD" && -f "$SLOW_SYNC_FILE" ]]; then
      (eval "$SLOW_SYNC_STOP_CMD") &
    fi
  fi
}

function cron {
  DISPLAY=:0.0 sync 2>&1 | timestamp >>"$DOT_DIR/log"
}

function timestamp {
  while read -r data
  do
      echo "[$(date +"%D %T")] $data"
  done
}

function acquire_lock {
  [ ! -d "$LOCK_DIR" ] && mkdir -p "$LOCK_DIR"
  if [ ! -d "$LOCK_DIR" ]; then
      echo -e "${RED}bitpocket error:${CLEAR} unable to create lock dir $LOCK_DIR"
      exit 2
  fi
  if [ -f "$LOCK_DIR/pid" ]
  then
    if kill -0 $(cat "$LOCK_DIR/pid") &>/dev/null
    then
      echo "There's already an instance of BitPocket syncing this directory. Exiting."
      exit 1
    else
      if [[ "${OPTIONS[*]}" =~ force ]]
      then
        echo -e "${YELLOW}Removing stale, local lock file${CLEAR}"
        rm -f "$LOCK_DIR/pid" && acquire_lock && return 0
      fi

      echo -e "${RED}bitpocket error:${CLEAR} Bitpocket found a stale lock directory:"
      echo "  | Root dir: $(pwd)"
      echo "  | Lock dir: $LOCK_DIR"
      echo "  | Command:  LOCK_PATH=$(pwd)/$LOCK_DIR && rm \$LOCK_PATH/pid "
      echo "Please remove the lock file and try again."
      exit 2
    fi
  fi

  echo $$ > "$LOCK_DIR/pid"
}

function release_lock {
  rm -f "$LOCK_DIR/pid" &>/dev/null 
}
#read the remote locks
#return locks in the variable REMOTE_STATE
#outdated in REMOTE_OUTDATED, other in REMOTE_OTHER, other from same host in LOCAL_OTHER
#return 0 if our own only or our is oldest, 1 if other, -1 if own not there or other error
#p1 our own lock file name
function read_remote_locks() {
    local old_ts=$(date "+%s")
    let "old_ts=$old_ts-$REMOTE_LOCK_TIMEOUT"
    rm -f "$REMOTE_STATE"
    REMOTE_STATE=()
    while IFS= read -r line
    do
        REMOTE_STATE+=("$line")
    done < <( rsync -e "$RSYNC_SSH_OPTIONS" $RSYNC_OPTS -r --list-only --filter="+ $DOT_DIR" --filter="+ $REMOTE_LOCK_DIR" --filter="+ $REMOTE_LOCK_DIR/*" --filter="- *" $REMOTE/ | sed -n "s?.*$REMOTE_LOCK_DIR/??p" | sed '/^ *$/d' )
    [ ${#REMOTE_STATE[@]} -lt 1 ] && return -2
    REMOTE_OUTDATED=()
    REMOTE_OTHER=()
    LOCAL_OTHER=()
    local hasOwn=0
    local ownIsOldest=1
    IFS=":" read -ra ownInfo <<< "$1"
    for line in "${REMOTE_STATE[@]}"
    do
        IFS=":" read -ra info <<< "$line"
        if [ "${info[2]}" -lt "$old_ts" ] ; then
            REMOTE_OUTDATED+=("$line")
        else
            if [ "$line" = "$1" ] ; then
                hasOwn=1
            else
                if [ "${info[0]}" = "${ownInfo[0]}" ] ; then
                    LOCAL_OTHER+=("$line")
                else
                    REMOTE_OTHER+=("$line")
                fi
                [ "${info[2]}" -lt "${ownInfo[2]}" ] && ownIsOldest=0
            fi 
        fi
    done
    [ "$hasOwn" != "1" ] && return -1
    [ "${#REMOTE_OTHER[@]}" = "0" -a "${#LOCAL_OTHER[@]}" = "0" ] && return 0
    [ "$ownIsOldest" = "1" ] && return 0
    return 1    
}

function acquire_remote_lock_rsync {
    #write our own lock file to the remote
    #and check if we are the only one
    #consider the REMOTE_LOCK_TIMEOUT and REMOTE_LOCK_WAIT
    local INFO="$HOSTNAME:$$:$LOCK_TIMESTAMP"
    if [ -d $REMOTE_LOCK_DIR ] ; then
        rm -f $REMOTE_LOCK_DIR/$INFO
    else
        mkdir -p $REMOTE_LOCK_DIR    
    fi    
    touch $REMOTE_LOCK_DIR/$INFO
    #write our lockfile to remote
    echo "#creating remote lock $REMOTE_LOCK_DIR/$INFO"
    rsync  -e "$RSYNC_SSH_OPTIONS" $RSYNC_OPTS -ra  --filter="+ $DOT_DIR" --filter="+ $REMOTE_LOCK_DIR" --filter="+ $REMOTE_LOCK_DIR/$INFO" --filter="- *" ./ $REMOTE/
    
    read_remote_locks "$INFO"
    local rstate=$?
    [ $rstate = 0 ] && return 0
    if [ "$rstate" -ne 1 ] ; then
        die "unable to acquire remote lock"
    fi
    local wait_time=$REMOTE_LOCK_WAIT
    while [ $wait_time -gt 0 ] 
    do
        if [ "${#REMOTE_OTHER[@]}" != "0" ] ; then
            echo "#other hosts having locks:"
            printf "%s\n" "${REMOTE_OTHER[@]}"
        else    
            local allStopped=1
            echo "#local other locks:"
            printf "%s\n" "${LOCAL_OTHER[@]}"
            for ll in "${LOCAL_OTHER[@]}"
            do
                local localInfo
                IFS=":" read -ra localInfo <<< "$1l"
                local pid="${localInfo[1]}"
                kill -0 $pid > /dev/null 2>&1
                if [ $? = 0 ] ; then
                    allStopped=0
                    break
                fi
            done
            if [ $allStopped = 1 ] ; then
                echo "locks from our host found without process, ignoring"
                return 0
            fi
        fi    
        sleep 1
        let "wait_time=$wait_time-1"
        echo "#waiting for remote lock for $wait_time seconds"
        read_remote_locks "$INFO"
        rstate=$?
        [ $rstate = 0 ] && return 0
        if [ "$rstate" -ne 1 ] ; then
            die "unable to acquire remote lock"
        fi
    done    
    local code=3
    echo -e "${YELLOW}Another client is syncing with '$REMOTE'${CLEAR}"
    printf "%s\n" "${REMOTE_OTHER[@]}"
    printf "%s\n" "${LOCAL_OTHER[@]}"
    cleanup
    exit $code
}

function release_remote_lock_rsync {
    local INFO="$HOSTNAME:$$:$LOCK_TIMESTAMP"
    if [ -d $REMOTE_LOCK_DIR ] ; then
        rm -f $REMOTE_LOCK_DIR/$INFO
    else
        mkdir -p $REMOTE_LOCK_DIR
    fi
    echo "#releasing remote lock $REMOTE_LOCK_DIR/$INFO"
    rsync -e "$RSYNC_SSH_OPTIONS" $RSYNC_OPTS -ra --delete --filter="+ $DOT_DIR" --filter="+ $REMOTE_LOCK_DIR" --filter="+ $REMOTE_LOCK_DIR/$INFO" --filter="- *" ./ $REMOTE/
}

function assert_dotdir {
  if [ ! -d "$DOT_DIR" ]; then
    echo "fatal: Not a bitpocket directory. Try 'bitpocket help' for usage."
    exit 128
  fi
  mkdir -p "$TMP_DIR"
  mkdir -p "$STATE_DIR"
}

function detect_fatfs {
    # Find the local mountpoint
    if [[ $LOCAL_MOUNTPOINT == false ]]
    then
        if builtin type -p findmnt &> /dev/null
        then
            LOCAL_MOUNTPOINT=$(until findmnt . >/dev/null; do cd .. ; done && findmnt -no TARGET .)
        else
            LOCAL_MOUNTPOINT=$(until $(mount | grep -Ew "$(pwd -P)" >/dev/null); do cd .. ; done && pwd -P)
        fi
    fi

    # Detect local mount is FAT and add appropriate
    local fsinfo=($(mount | grep -Ew "${LOCAL_MOUNTPOINT}"))
    local fstype=${fsinfo[4]}

    if [[ $fstype == *fat ]]
    then
        RSYNC_OPTS="${RSYNC_OPTS} --no-perms --no-owner --no-group --modify-window=2"
    fi

    # TODO: Consider remote filesystem type?
}


function cleanup {
  release_lock
  release_remote_lock_rsync
}

function bring_the_children_let_me_kill_them {
  if [ -n "$shell_pid" ]; then
    pkill -P $shell_pid &>/dev/null
    kill $shell_pid &>/dev/null
  fi
}

function die {
  cleanup
  bring_the_children_let_me_kill_them

  echo -e "${RED}fatal${CLEAR}: command failed $1"
  exit 128
}

function intr_cleanup {
  die "${YELLOW}Interrupted${CLEAR}"
}

trap intr_cleanup SIGINT

# List all files in the sync set
function list {
  echo -e "${GREEN}bitpocket${CLEAR} will sync the following files:"
  rsync -av --list-only --exclude "/$DOT_DIR"  $USER_RULES . \
      | scrub_rsync_list \
      | strip_mode \
      | sort
}


# By default, run the sync process
[[ ${#COMMANDS} == 0 ]] && COMMANDS+=('sync')

# For now, only one command really makes sense
case ${COMMANDS[0]} in
    init)       init "${ARGS[@]}";;
    pack)       pack;;
    log)        log;;
    cron)       cron;;
    list)       list;;
    help)       usage;;
    sync)       sync;;
esac
